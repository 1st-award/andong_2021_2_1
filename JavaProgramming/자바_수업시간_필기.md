# 자바 프로그래밍
- 자바수업시간에 안된다고 했던것들 예제에 적용해보자
- API만 주고 문제푸는 문제 나올 수 있음

## ====접근 제어====
- 클래스나 메서드 앞에 접근 제어자가 안붙어 있으면 default값으로 같은 패키지 안에서만 쓸 수 있는 pakage가 붙는다.
- 생성자(cunstruct)의 조건: return 값이 있어선 안된다. 클래스 네임과 같아야한다.

## ====정적 변수====
- 정적 변수는 객체에 생성되는게 아니라 클래스 영역에 생성된다
- 클래스의 static 변수: 클래스 내에서는 정보만 갖고있는다
- 클래스 영역 메모리에 변수를 갖는다
- 객체영역에서는 클래스 내에있는 변수에서 참조한다

## ====정적 메소드====
- 정적 메서드는 객체를 생하지않고 메소드를 호출할 수 있다.
- 객체 변수와 동일하게 클래스 메모리에 저장된다.
- 객체 매서드는 메서드 안에의 변수만 사용할 수 있다.
- 같은 클래스라 할지라도 클래스 필드에있는 변수는 사용할 수 없다.

## ====참조 변수대입====
- 두개의 객체를 선언하고 하나의 참조변수를 다른하나를 가리키게하면 
- 기존의 객체가 없어지고 두개의 참조변수가 하나의 객체를 갖게된다.

## ====메소드로 인수 전달 방법====
-메소드로 기초형 변수가 전달되는 경우   -> 기초형 변수의 값이 복사되어 전달된다. (기초형 변수에는 영향을 미치지 않는다)
-메소드로 객체가 전달되는 경우          -> 객체의 주소 값이 복사되어 전달된다. (주소를 복사하기 때문에 객체에 영향을 미친다)
-메소드로 배열이 전달되는 경우          -> 배열의 주소 값이 복사되어 전달된다. (주소를 복사하기 때문에 배열에 영향을 미친다)

## ====객체 배열====
- 기초형 배열: 값을넣는 칸이 생김(값을 바로 넣을 수 있다)
- 객체 배열: 객체에 대한 참조값 칸이 생김(값을 바로 넣을 수 없다)
- 동적 객체 배열(ArrayList): 객체를 유동적으로 사용할 수 있는 배열

## ====내장 클레스====
- 클래스 안에 클래스를 정의할 수 있다.
- 내부 클래도 사용하려면 객체를 생성해야된다.

## ====상 속====
- 상속을 정의하려면 자식 클래스 이름 뒤에 extends를 써주고 부모 클래스 이름을 적어주면 된다.
- 상속이 왜 필요한가? -> 코드를 재사용할 수 있다. 중복을 회피할 수 있다. 자식 클래스는 부모 클래스에 종속된다.
  자식 클래스에서 상속 받는 것을 파악하려면 상속 계층을 모두 거슬러 올라가봐야한다.
- 상속을 하게되면 상위클래스의 코드를 복사해온다.
- 일반화: 자식클래스->부모클래스
- 하위범주화(특수화): 자식클래스<-부모클래스
- 인스턴스화: 객체 -> 클래스
- 클래스화: 객체 <- 클래스
- 파생클래스 = 자식클래스
- 상위클래스 = 부모클래스
- 널 파라메터, 널 바디, 널 클래스
- 최상위 클래스 부터 실행된다
- super(): 상위 클래스에있는 생성자를 실행 시킬 수 있다. (this랑 쓰임세가 비슷 this : 현재 인스턴스를 가르킴)
- 시그니처: 메소드의 이름, 매개변수

## ====메소드 재정의(mothod overriding)====
- 오버라이딩: 자식 클래스가 필요에 따라 상속된 메소드를 다시 정의하는 것. 이때, 파라미터 개수와 데이터 타입이 일치해야한다.
- 오버로딩: 동일한 이름에 서로 다른 메개변수를 같는것
- 메소드의 이름, 매개변수의 개수와 데이터 타입이 일치하여야한다.
- 묵시적으로 자식 클래스에는 상위 클래스 널 파라메터가 생성된다.

## ====추상 클래스(abstract class)====
- 추상 클래스: 몸체가 구현되지 않은 메소드를 가지고 있는 클래스 추상적인 개념을 클래스화하였으므로, 실제 객체가 존재하지 않는 클래스이다.
- 따라서 객체를 생성할 수 없다. 하지만, 보통의 메서드도 가질 수 있다.
- 추상 클래스를 달지 않은 상태로 추상 메서드를 사용할 순 없다.
- 추상 클래스에서 추상 메서드를 정의하면 자식 클래스는 무조건 추상 메서드를 선언해야한다.
- 추상 매서드를 선언하면 추상 클래스가 필수적이며, 추상 매서드를 선언할 때 public을 붙여줘야 한다.

## ====다향성====
- 다향성: 객체들의 타입이 다르면 똑같은 메세지가 전달되더라도 서로 다른 동작을 하는 것
- new는 컴파일러 입장에서 연산기호다
- new라고 꼭 객체를 선언하는것은 아니다 (ex. interface, 추상클래스) 
- 부모 클래스 참조변수가 자식 클래스 객체를 참조할 수 있다. 이를 상향 형변환이라고 한다.
- 부모 클래스 참조변수가 부모 클래스 객체를 참조할 때 자식 클래스의 변수를 사용하지 못한다. (자식을 상속 받지 못하기 때문)
- 
## ====인터페이스====
- 인터페이스: 인터페이스는 추상 메소드로 이루어진다. __인터페이스 안에서 필드는 선언 될 수 없다. 상수는 정의할 수 있다.__
- 인터페이스 안의 모든 메소드는 public과 abstract를 붙이지 않아도 같은 취급을 받는다.
- implements로 구현 클래스를 만들어 줘야한다.
- 일반 클래스는 상속과 인터페이스를 동시에 받을 수 있다.
- 인터페이스는 다중구현을 할 수 있다. 즉, 클래스는 2개 이상의 인터페이스를 상속받을 수 있다.
- 객체를 선언할 때 상위타임<-하위타입은 가능하지만 하위타임<-상의타입은 에러가 난다
	ex) animal<- dog(o), dog<-animal(x)
- extends를 하면 변수는 이름만 가져온다
- interface는 오퍼레이션(추상클래스)만으로 정의된다. static final 상수는 가능
- interface는 여러개 받을 수 있다(다중 구현이 가능하다)
- 스윙에서 키보드 마우스는 인터페이스로 구현되어 있다

## ====패키지====
- 패키지는 서로 관련 있는 클래스나 인터페이스들을 하나로 묶은 것 이다
- 가상 머신이 클래스 파일을 찾는 디렉토리들을 클래스 경로(class path)라고 한다

## ====오브젝트 클래스(Object 클래스)====
- toString() : 객체의 문자열을 표현을 반환한다 -> println()을 사용하여 객체를출력하면 객체의 toString() 메소드가 자동으로 호출된다. 오버라이딩 하려면 public을 앞에 붙여줘야한다.
- equals() : 서로 다른 객체의 값을 비교할 때 사용된다. (값이 동일하면 true, 아니면 else), == 은 참조값을 비교하는 연산자이다. 오버라이딩 하려면 public을 앞에 붙여줘야한다.

## ====래퍼 클래스(Wrapper 클래스)====
- 정수와 같은 기초 자료형을 객체로포장하고 싶은 경우에 사용된다.
- 랩퍼 객체 -> 기초 자료형 : 오토 언박싱
- 기초자료형 -> 랩퍼 객체 : 오토 박싱
- 명시적인 박싱: 프로그래머가 박싱, 언박싱 변환하는 것 (Integer obj = (Integer)100)
- 묵시적인 박싱: 자동으로 박싱, 언박싱 변환하는 것 (Integer obj = 100)

## ====StringBuffer 클래스====
- StringBuffer 객체는 내부적으로 문자열을 저장하는 메로리를 가지고 있다.
- StringBuffer 객체 만들기 : StringBuffer sb = new StringBuffer("10+20="); // 10+20=
- StringBuffer 추가하기(append) : sb.append(10+20); // 10+20=30
- StringBuffer 삽입하기(insert) : sb.insert(0, "수식 "); // 수식 10+20=30

## ====예외처리(Exception)====
- 오류가 발생했을 때 사용자에게 알려주고 모든 데이터를 저장 후 우아하게 프로그램을 종료할 수 있도록 하는 것
- 오류발생 즉시 그 라인에서 바로 catch로 넘어간다.
- finally는 예외처리가 되는 되지않든 실행된다.
- try가 종료되면 FileReader도 자동으로 종료된다.
- throws는 현제 있는 메소드 '밖'에서 다른 메소드한테 예외 처리를 맡긴다.
- throw는 현제 있는 메소드 '안'에서 다른 메소드한테 예외 처리를 맡긴다.

## ====자바 GUI 종류====
|JAVA AWT|JAVA Swing|
|:---:|:---:|
|플랫폼에 의존적이다.|플랫폼에 독립적이다.|
|컴포넌트 용량이 크다.|컴포넌트 용량이 가볍다.|
|룩앤필을 지원하지 않는다.|룩앤필을 지원한다.|
|컴포넌트의 개수가 적다.|컴포넌트의 개수가 많다.|

## ====컨테이너와 컴포넌트====
- 컨테이너 컴포넌트 : 다른 컴포넌트를 안에 포함할 수 있는 컴포넌트
- 컴포넌트 : 컨테이너 안에 넣을 수 있는 컴포넌트

## ====컨테이너 종류====
- 최상위 컨테이너: 다른 컨테이너안에 포함될 수 없는 컨테이너
- 일반 컨테이너: 다른 컨테이너 안에 포함될 수 있는 컨테이너

## ====JFrame 클래스====
- 컨테이너는 컴포넌트들의 트리로 구성되어있다. 최상위 컨테이너는 루트 노드
- 최상위 컨테이너는 화면에 보이는 컴포넌트를 저장하는 콘텐트 페인을 가지고 있다.
- 최상위 컨테이너에는 메뉴바를 추가할 수 있다.

## ====배치 관리자====
- 컨테이너 안의 각 컴포넌트의 위치와 크기를 결정하는 작업
- BorderLayout: 컴포넌트들이 동, 서, 남, 북, 중간 중 하나로 추가된다.
- FlowLayout: 컨포넌트들을 왼쪽에서 오른쪽으로 버튼을 배치한다. 패널과 애플릿의 디폴트 배치 관리자다.
- GridLayout: 컴포넌트를 격자 모습으로 배치한다.
- null: 컨폰넌트를 사용자가 원하는 위치에 배치한다.

## ====패널====
- 컨포넌트들을 포함하고 있도록 설계된 컨테이너 중의 하나이다.
- 화면을 2개로 나누어서 표시하고자 할 때 패널을 사용한다.

## ====레이블====
- 편집이 불가능한 텍스트를 표시

## ====텍스트 필드====
- 입력이 가능한 한 줄의 텍스트 필드를 만드는데 사용
- JTextField textField = new JTextField(20); //20칸의 텍스트 필드 생성

## ====버튼====
- 사용자가 사용했을 경우, 이벤트를 발생시켜 원하는 동작을 하게 하는데 사용
- JButton - 가장 일반적인 버튼
- JCheckBox - 체크박스 버튼
- JRadioButton - 다수의 버튼 중 하나의 버튼만 체크할 수 있는 버튼

## ====키 이벤트====
- 키 이벤트는 사용자가 키보드를 이용하여 입력을 하는 경우에 발생한다.
- 키 이벤트는 인터페이스이므로 메소드를 안쓰더라도 전부 선언해줘야한다.
- KeyPressed: 키를 눌럿을 때 호출
- KeyReleased: 키를 땟을 때 호출
- KeyTyped: 글자를 입력했을 때 호출
- KeyEvent가 발생하려면 컴포넌트가 반드시 키보드 포커스를 가지고 있어야 한다.

## ====마우스 이벤트====
- 마우스 이벤트도 키 이벤트와 마찬가지로 메소드를 안쓰더라도 전부 선언해줘야한다.
### ====MouseListener====
- mousePressed: 컴포넌트위에서 눌려지면 호출된다.
- mouseReleased: 컴포넌트위에서 때어지면 호출된다.
- mouseEntered: 컴포넌트로 들어가면 호출된다.
- mouseExited: 컴포넌트에서 나가면 호출된다.
- mouseClicked: 컴포넌트를 클릭한 경우에 호출된다.
### ====MouseMotionListener====
- mouseDragged: 드래그하면 호출된다.
- mouseMoved: 클릭되지 않고 이동하는 경우에 호출된다.

## ====어댑터 클래스====
- 리스너를 이용하면 사용하지 않을 메서드라도 널 바디로 전부 구현해야하는 불편함이 있다.
- 어댑터를 사용하면 이미 널바디가 만들어진 상태여서, 필요한 이벤트만 오버라이딩할 수 있다.
